---
layout: post
title: "(어거지) 어쩌다 거얼린 지식 - 시간복잡도 / 빅오(Big O) 계산"
author: "rmfls2017"
tags: [time-complexity, accessor, getter, setter]
image: 345.jpg
---

# 시간복잡도

가장 널리 사용되는 알고리즘의 수행시간 기준으로, 알고리즘이 실행되는 동안 수행하는 기본적인 연산의 수를 입력의 크기에 대한 함수로 표현한 것

기본적인 연산이란 더 작게 쪼갤 수 없는 최소 크기의 연산이라고 생각하면 됨

시간 복잡도가 높다는 말은 입력의 크기가 증가할 떄 알고리즘의 수행 시간이 더 빠르게 증가한다는 의미

하지만, 시간 복잡도가 낮다고 해서 언제나 더 빠르게 동작하는 것은 아님, 입력의 크기가 충분히 작을 떄는 시간 복잡도가 높은 알고리즘이 더 빠르게 동작할 수 있는 가능성 있음

컴퓨터과학에서 알고리즘의 시간복잡도는 입력을 나타내는 문자열 길이의 함수로서 작동하는 알고리즘을 취해 시간을 정량화하는 것 

알고리즘의 시간복잡도는 주로 빅-오 표기법을 사용하여 나타내며, 이 빅-오 표기법은 계수와 낮은 차수의 항을 제외시키는 방법

이런 방식으로 표현할 때, (예를 들면, 입력 크기를 무한대로 입력하여) 시간복잡도를 점근적으로 묘사한다고 말함

## 알고리즘 문제와 연관성

알고리즘의 수행 시간을 지배하는 바로 반복문

입력의 크기가 커지면 커질수록 반문복이 알고리즘의 수행 시간을 지배, 따라서 알고리즘의 수행 시간을 반복문이 수행되는 횟수로 측정함

예시로 아래의 코드를 통해 설명

```cpp
// A 의 각 원소가 0부터 100 사이의 값일 경우 가장 많이 등장하는 숫자를 반환한다
int majority1(const vector<int>& A) {
    int N = A.size();
    vector<int> count(101, 0);
    for(int i = 0; i < N; ++i) {
        count[A[i]]++;
    }

    // 지금까지 확인한 숫자 중 빈도수가 제일 큰 것을 majority 에 저장한다
    int majority = 0;
    for(int i = 1; i <= 100; ++i) {
        if (count[i] > count[majority]) {
            majority = i;
        }
    }

    return majority;
}
```

예시에서 가르키는 반복문은 총 2개도 전달받은 값의 길이만큼과 그 길이에서 100 만큼을 더 수행하는 작업을 수행

위의 작업은 `N + 100` 의 작업 수행을하므로 알고리즘의 수행은 `N` 에 절대적으로 영향이 미치므로 수행시간은 `N` 이라고 표시

계산 복잡도 이론에서 시간 복잡도는 문제를 해결하는데 걸리는 시간과 입력의 함수 관계를 가르킴

# 빅오 (Big O) 계산 (점근적 시간 표기)

O 표기법 (Big-O Notation) 이라는 것을 사용해 알고리즘의 수행 시간을 표기

O 표기법은 간단하게 말해 주어진 함수에서 가장 빨리 증가하는 항만을 남긴 채 나머지를 다 버리는 표기법

예시로서, 만약 크기 n의 모든 입력에 대한 알고리즘에 필요한 시간이 최대 (어떤 n0보다 크지 않은 모든 n에 대하여) 5n3 + 3n의 식을 가진다면, 이 알고리즘의 점근적 시간 복잡도는 O(n3)이라고 할 수 있음

## O 표기법의 의미

O 표기법은 대략적으로 함수의 상한을 나타낸다는데 의미가 있음

예시로 함수 `f(n) = O(g(n))` 이라고 쓰는 것은 다음과 같은 의미를 지님

```text
아주 큰 N_ 과 C(N_, C > 0) 를 적절히 선택하면 N_ <= N 인 모든 N 에 대해 |f(n)|<=C*|g(N)| 이 참이 되도록 할 수 있다
```

N^2 + 100 * N + 1 = O(N^2) 라고 씀, N^2 는 N^2 + 100 * N + 1 보다작지만, 이 중에서 가장 빨리 증가하는 항이라고 볼 수 있음

따라서 N 이 엄청나게 커지게되면 N^2 와 N^2 + 100 * N + 1 사이에는 그 다지 큰 차이가 없음

이 때, 적절한 상수 C 를 선택해서 N^2 에 곱해주면 항상 N^2 이 더 크다고 할 수 있다는 얘기

## O 표기법의 오해

O 표기법이 수행 시간의 상한을 나타낸다는 사실을 통해 알고리즘의 최악의 수행 시간을 알아냈다고 착각하는 일이 흔히 있음

예를 들어 퀵 정렬의 최악의 수행 시간을 분석해보면 최도차항이 N^2 임을 알 수 있고, 따라서 퀵 정렬의 최악의 시간 복잡도는 O(N^2) 으로 표시함

그러나 평균 수행시간을 계산해 보면 최고차항이 NlogN 이고, 따라서 퀵 정렬의 평균 시간 복잡도는 최악의 경우와 달리 O(NlogN) 이 됨

---

# Reference

* 프로그래밍 대회에서 배우는 알고리즘 문제해결전략 (구종만) - 4. 알고리즘의 시간 복잡도 분석
* 위키백과 - 시간복잡도 [링크](https://ko.wikipedia.org/wiki/%EC%8B%9C%EA%B0%84_%EB%B3%B5%EC%9E%A1%EB%8F%84)