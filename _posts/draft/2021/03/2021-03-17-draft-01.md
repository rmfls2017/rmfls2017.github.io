---
layout: post
title: "2021.02.19 - 초안 "
author: "rmfls2017"
categories: draft
tags: [draft]
image: quill-paper-pens.png
---

# 안드로이드 개발 삽질기 1탄

안드로이드 Thread 를 통해서 작업해야할 일이 생겼다.

Thread 를 사용하지 않았을 뿐 더러 안드로이드라는 영역에서 개발하려고 하니 힘들 점이 있어서 글을 적고자한다.

## 목표

`특정한 시간마다` 미리 지정된 시간에 이벤트를 실행한다.

## 과정

특정한 시간마다라는 말은 규칙적으로 시간이 흘러가야하고 미리 지정된 시간이되면 이벤트가 실행되야하므로 새로운 Thread 를 생성해서 그 Thread 안에서 시간을 체크하여 확인을 해야한다.

### 왜 Thread?

먼저 왜 새로운 Thread 를 선택했고 생성해야 하는지 이유를 살펴보자.

> ... Specifically, if everything is happening in the UI thread, performing long operations such as network access or database queries will block the whole UI. When the thread is blocked, no events can be dispatched, including drawing events. ...

UI thread 내에서 모든 일이 발생한다면 (데이터 조회 및 서버와의 통신 등의 문제 일) 전체적인 결과가 반환될 때까지 UI 는 block 이 될 것이며, block 이 될 경우에는 rendering 을 포함한 어떠한 이벤트로 thread 로 전달할 수 없다.

이 문장을 보면 끔찍하다고 생각헀다. Multi Thread 에 대해서 모른는 상태에서 하나의 Thread 안에 작동되게 할 것인데, 모든 UI Thread 를 막는다면 앱이 멈췄는지 작동하는지를 모를 것이다.

> However, note that you cannot update the UI from any thread other than the UI thread or the "main" thread.

그러나 UI 스레드가 아닌 다른 스레드에서는 UI를 업데이트 할 수 없다.

> However, as the complexity of the operation grows, this kind of code can get complicated and difficult to maintain. To handle more complex interactions with a worker thread, you might consider using a `Handler` in your worker thread, to process messages delivered from the UI thread.

하지만, 작업이 어려워진다면 이러한 코드는 복잡해지고 유지하기가 힘들어질 것이다. Worker Thread 에서 복잡한 코드를 다루려면, UI Thread 에서 전달된  message 객체를 통해 Handler 에서 처리하는 것을 고려하는 것이 좋다.

기본적으로 Thread 작업을 하기 위해서는 새로운 Runnable 객체가 필요하는데 Runnable 을 구현하는 (@Override run(){}) class 가 필요하다.

```java
protected class TimeRunnable implements Runnable {
    @Override
    public void run() {
        runTask();
    }
}
```
그리고 Runnable 를 구현하는 class 에 Thread 에 넘겨주면 해당 Thread 는 Runnable class 에서 Override 한 run() 을 실행한다.

```java
Thread nThread = new Thread(new TimeRunnable());
nThread.start();
```

이 문장에서 보듯이 다른 방법은 `Handler` 를 사용해서 처리할 수 있는데, 이 Handler 에 대해서는 다음 포스팅에서 알아보도록 하고 Thread 작업 과정을 통해 요구사항을 수행하도록 하자.

---

    첫번째, 특정한 시간이라는 것은 기준이 되는 시간과 특정한 시간에 도달하면 실행을 시켜야하므로 `기준이 되는 시간` 과 `실행될 시간` 을 가지고 있어야한다.

    두번째, `기준이 되는 시간`은 초 단위로 흘러가야하기 때문에 Thread 에서 지속적으로 확인하고 있어야한다.

---

위 두 사항을 고려하여 기준이 되는 시간을 정하자.

기준이 되는 시간: Thread 를 새로 생성하여 안에 while loop 를 돌며 1초씩 증가하는 시간, 이 때 Thread.sleep 으로 1000ms 을 설정한다.

실행될 시간: 기준이 되는 시간이 실행될 시간과 맞는다면 이벤트를 실행시킨다.

* NewThreadTest.java
```java
protected class TimerRunnable implements Runnable {
    @Override
    public void run() {
        while (!Thread.currentThread().isInterrupted()) {
            try {
                if (baseDefaultTime == eventTime) {
                    runTast();
                }

                Thread.sleep(1000);
            } catch (InterruptedException ex) {
                break;
            }
        }
    }
}

private void startThread() {
    Thread nThread = new Thread(new TimerRunnable());
    nThread.start();
}
```