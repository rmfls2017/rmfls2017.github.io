---
layout: post
title: "(어거지) 어쩌다 거얼린 지식 - 소수점 계산 (feat. float)"
author: "rmfls2017"
tags: [time-complexity, accessor, getter, setter]
image: 345.jpg
---

컴퓨터 계산을 하다보면은 가끔 소수점 아래의 숫자로 계산을 해야할 때가 있다.

작성자의 경우에 원화에서 달러로 변환을할때 `원화 => 센트 => 달러` 순 으로 변환을 하게됐는데, `원화 => 센트` 로 변환할 때의 문제가 발생했다.

분명 나누어떨어지는 숫자임에도 소수점 아래를 올림하는 함수를 사용하여 숫자를 적용하면 올림처리하게 되면서 1이 더해지는 현상을 발견하게됐다.

수기로 직접 계산을 했는데 컴퓨터 계산을 할 때 자꾸 숫자가 올라가서 어떤 부분이 문제인지 파악하던 중 소수점 아래에서의 계산이 이상하게 된다는 것을 깨닫고 어떠한 과정으로 해결을 하고 전반적인 소수점 아래의 계산은 어떻게 이뤄지는지 이 내용을 기록하고자 한다.

# 부동소수점

당장에 가서 웹브라우저에 개발자 옵션을 띄우고 (F12 누르거나 Ctrl + Shift + C 를 눌러 개발자 도구 창을 활성화) `Console` 탭에 들어가 아래의 숫자를 입력해보자

```javascript
0.1 + 0.2 == 0.3
> false
```

사람이 계산한다면 분명히 0.3 이 결과로 나오고 이 결과는 우변에 있는 0.3 과 같아야하는데 결과값으로 false 가 나온다.

이유가 뭘까?

정답은 컴퓨터에 소수점을 저장하는 방식에서의 차이로 인해 위와 같은 결과가 나오게된다.

부동소수점이라는 말은 뭘까?

부동소수점은 한자표기로 `浮動小數點` 뜻은 뜰 부, 움직일 동, 작을 소, 셈 수, 점 점 뜻을 풀어쓴다면 작은 수의 점이 떠서 움직인다는 뜻으로 컴퓨터 에서 실수 표기를 하는 방법으로, 소수점의 위치를 고정시키지 않으며 가수와 지수를 사용하여 실수를 표현한다. 

실제 컴퓨터에서는 보통 이진법을 사용하여 다음과 같이 세 부분의 값으로 실수를 나타낸다.

- 부호부 (1비트) : 양수일 때는 0, 음수일 때는 1
- 지수부 (부호가 없는 정수, 8비트) : 8비트로 표시
- 정규화된 가수부 (부호가 없는 정수, 23비트) : 제일 앞의 비트는 정규화되었으므로 1이다.

![그림](https://upload.wikimedia.org/wikipedia/commons/thumb/8/88/General_floating_point_ko.svg/500px-General_floating_point_ko.svg.png)

# 자리수 계산

위의 그림처럼 float 계산은 어떻게 해야할까?

```
예시
−118.625 (십진법)을 IEEE 754 (32비트 단정밀도)로 표현해 보자.

음수이므로, 부호부는 1이 된다.

그 다음, 절댓값을 이진법으로 나타내면 1110110.101이 된다. (이진기수법을 참조)

소수점을 왼쪽으로 이동시켜, 왼쪽에는 1만 남게 만든다. 예를 들면 1110110.101=1.110110101×2⁶ 과 같다. 이것을 정규화된 부동소수점 수라고 한다.

가수부는 소수점의 오른쪽 부분으로, 부족한 비트 수 부분만큼 0으로 채워 23비트로 만든다. 결과는 11011010100000000000000이 된다.

지수는 6이므로, Bias를 더해야 한다. 32비트 IEEE 754 형식에서는 Bias는 127이므로 6+127 = 133이 된다. 이진법으로 변환하면 10000101이 된다.
```

![그림](https://upload.wikimedia.org/wikipedia/commons/thumb/6/68/Float_point_example_frac.svg/600px-Float_point_example_frac.svg.png)

# 정확도 문제

부동소수점 덧셈과 곱셈은 모두 교환법칙 (a + b = b + a 이고 a × b = b × a)이 성립하지만, 꼭 결합법칙이 성립하지는 않는다. 즉, (a + b) + c 이 항상 a + (b + c) 과 같지는 않게 된다. 예를 들면 7자리 부동소수점(Float 7) 10진수 계산을 할 때:

```
 1234.567 + 45.67846 = 1280.245
                       1280.245 + 0.0004 = 1280.245
 그러나
 45.67846 + 0.0004 = 45.67886
                     45.67886 + 1234.567 = 1280.246
```

또한 항상 분배법칙이 성립하지도 않는다. 즉, (a + b) × c 은 a × c + b × c과 다를 수 있다:

```
 1234.567 × 3.333333 = 4115.223
 1.234567 × 3.333333 = 4.115223
                       4115.223 + 4.115223 = 4119.338
 그러나
 1234.567 + 1.234567 = 1235.802
                       1235.802 × 3.333333 = 4119.340
```

유효 숫자를 잃어버리는 문제 뿐만 아니라, π와 0.1를 정확하게 표현하지 못하는 문제와 다른 약간의 부정확성이 다음과 같은 현상을 일으킨다:

- 소거: 거의 같은 두 값을 빼는 것은 정확성을 매우 많이 잃게 된다. 이 문제가 아마도 가장 일반적이고 심각한 정확도 문제이다.

- 정수로의 변환 문제: (63.0/9.0)을 정수로 변환하면 7이 되지만 (0.63/0.09)는 6이 된다. 이는 일반적으로 반올림 대신 버림을 하기 때문이다.

- 제한된 지수부: 결과값이 오버플로되어 무한대값이 되거나 언더플로되어 비정규 값 또는 0이 될 수 있다. 만약 비정규 값이 되면 유효숫자를 완전히 잃어버린다.

- 나눗셈이 안전한지 검사하는데 문제가 생김: 제수(나눗수)가 0이 아님을 검사하는 것이 나눗셈이 오버플로되고 무한대값이 되지 않는 걸 보장하지 않는다.

- 같음을 검사하는데 문제가 생김: 수학적으로 같은 계산결과가 나오는 두 계산 순서가 다른 부동소수점 값을 만들어낼 수 있다. 프로그래머는 어느정도의 허용 오차를 가지고 비교를 수행하지만, 그렇다고 해서 문제가 완전히 없어지지 않는다.

---

# Reference

- Microsoft Docs - float 형식 (https://docs.microsoft.com/ko-kr/cpp/c-language/type-float?view=msvc-170)
- Wikipedia - 부동소수점 (https://ko.wikipedia.org/wiki/%EB%B6%80%EB%8F%99%EC%86%8C%EC%88%98%EC%A0%90)
- 네이버 지식백과 - 부동소수점 (https://terms.naver.com/entry.naver?docId=3346159&cid=40942&categoryId=32828)